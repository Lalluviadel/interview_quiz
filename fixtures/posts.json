[
{
  "model": "posts.post",
  "pk": 2,
  "fields": {
    "title": "Разница между == и is",
    "author": "drf",
    "category": 1,
    "body": "<div><div>С первого взгляда оба варианта сравнения объектов идентичны. Но обратив внимание на то, что именно сравнивается, мы обнаружим различие.</div><div>При использовании == мы сравниваем <b>содержимое</b>, а с помощью is определяем <b>идентичность</b>.</div>Каждый объект при создании получает уникальный идентификатор области памяти, которая для него зарезервирована. Этот идентификатор будет отличаться при каждом запуске программы.<div>На картинке видно, что при создании первого объекта резервируется область памяти, которой мы присвоили переменную (ссылку на эту область) под именем <b>a</b>. Переменная <b>b</b> - всего лишь еще одна ссылка на эту область памяти. А вот переменная <b>c</b> ссылается на уже совершенно новый объект, который был создан заново, пусть и с тем же содержимым.</div><div>Поэтому при сравнении содержимого (==) мы получим результат True, а при сравнении идентичности объектов (is) мы получим результат False, так как a и c - два совершенно разных объекта.</div></div>",
    "image": "post_images/Разница_между__и_is_equal.jpg",
    "created_on": "2022-02-28T22:41:23.251Z",
    "available": true,
    "tag": "равенство"
  }
},
{
  "model": "posts.post",
  "pk": 3,
  "fields": {
    "title": "Генератор в Python",
    "author": "drf",
    "category": 1,
    "body": "<div><div>Генератор - удобный объект, экономящий оперативную память. Он последовательно возвращает значения вычислений, но хранит в памяти <b>только последнее</b>. При окончании последовательности последнее значение будет стерто, а попытка обратиться к генератору за получением нового значения вызовет исключение StopIteration.</div><div>Генераторы очень удобны в случаях, когда необходимо обработать большой объем информации. Если одномоментно разместить весь объем в памяти, она будет исчерпана, поэтому списки и другие подобные объекты Python будут непригодны. Генератор позволит выполнить все нужные вычисления, не перегрузив память. Стандартный способ запросить новое значение из функции генератора - метод <b>next()</b>. В функциях генераторах вместо return используют <b>yield</b>. Это ключевое слово неявно вызывает next(), тем самым значения выдаются по одному, а также сохраняется состояние генератора на текущий момент.</div><div>Используются и анонимные функции генераторы - генераторные выражения. В них отсутствует yield или next() в явном виде, поэтому начинающие питонисты их часто путают с list comprehensions. Одно из таких выражений можно увидеть на картинке к этой статье.</div></div>",
    "image": "post_images/Генератор_в_Python_generator.png",
    "created_on": "2022-02-28T22:42:41.057Z",
    "available": true,
    "tag": "генератор"
  }
},
{
  "model": "posts.post",
  "pk": 4,
  "fields": {
    "title": "Тернарный оператор в Python",
    "author": "drf",
    "category": 1,
    "body": "<div><div>Тернарный оператор является заменой для стандартного использования операторов условия <b>if/else</b>, если действие достаточно простое, чтобы имело смысл написать его в одну строку. </div><div>При использовании тернарного оператора участвуют все те же if и else и выражение, которое мы проверяем на <b>True/False</b>. В зависимости от этого значения выполняется одно из условий. Соответствующий результат присваивается переменной.</div><div>Использование тернарного оператора обосновано для сокращения кода только в случае, если это не ухудшает читаемости этого кода.</div><div>Приоритет этого оператора - наиболее низкий.</div><div>",
    "image": "post_images/Тернарный_оператор_в_Python_ternarny.png",
    "created_on": "2022-02-28T22:43:37.268Z",
    "available": true,
    "tag": "тернарный оператор"
  }
},
{
  "model": "posts.post",
  "pk": 5,
  "fields": {
    "title": "Инкапсуляция, полиморфизм, наследование",
    "author": "drf",
    "category": 1,
    "body": "<div><div>Python - язык, созданный в рамках модели объектно-ориентированного программирования. В ее основе лежат три понятия: инкапсуляция, полиморфизм и наследование.</div><div><b>Инкапсуляция</b> - ограничение доступа к атрибутам объекта (методам, переменным). В Python на самом деле все атрибуты являются публичными - то есть к ним все же можно получить доступ. Но для соответствия парадигме ООП принято соглашение об особом именовании скрытых атрибутов. При задействовании таких атрибутов в своем коде разработчик имеет понимание, что эти атрибуты условно считаются ограниченными для доступа, их использование не рекомендуется для избегания конфликтов.</div><div><b>Полиморфизм</b> - возможность модифицировать (переопределять) любой метод любого класса или оператор, за счет чего меняется его поведение. Например, при перегрузке оператора сложения __add__() мы можем заставить его одновременно выводить на экран сегодняшнее число.</div><div><b>Наследование</b> - возможность создания дочерних классов, которые будут иметь атрибуты родительского. При этом мы можем добавить для наследников уникальные атрибуты или переопределить те, что были унаследованы от родителя. Например, можно создать свой класс списка, в котором переопределим метод append.</div></div>",
    "image": "post_images/Инкапсуляция_полиморфизм_наследование.jpg",
    "created_on": "2022-02-28T22:44:16.926Z",
    "available": true,
    "tag": "ООП"
  }
}
]
